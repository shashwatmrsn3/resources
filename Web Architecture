1. API Design
RESTful API best practices and standards

API versioning strategies and backward compatibility

Designing GraphQL schemas and query optimization

Rate limiting, throttling, and quota enforcement

Idempotency and safe API methods

Handling API errors and standardized response formats

Public vs internal API design considerations

Pagination, filtering, sorting in API responses

2. Caching
Cache invalidation strategies (write-through, write-back, write-around)

Cache eviction policies (LRU, LFU, FIFO)

CDN caching and edge caching concepts

Client-side vs server-side caching

Distributed caching and cache coherence

Cache stampede and how to prevent it

Cache warming and lazy loading

Use of Redis, Memcached, and in-memory caches

3. Authentication
OAuth 2.0 flows and OpenID Connect

JWT (JSON Web Tokens) structure and security considerations

Session-based vs token-based authentication

Multi-factor authentication (MFA) strategies

Single Sign-On (SSO) and identity federation

Token revocation and refresh token handling

Secure storage and transmission of credentials

Role-based and attribute-based access control

4. Web Security
OWASP Top 10 vulnerabilities and mitigations

Cross-Site Scripting (XSS) and Content Security Policy (CSP)

Cross-Site Request Forgery (CSRF) protection techniques

HTTPS, TLS, and secure transport layer concepts

CORS (Cross-Origin Resource Sharing) policies and challenges

SQL Injection prevention and parameterized queries

Security headers (HSTS, X-Frame-Options, etc.)

Security logging, monitoring, and incident response

5. Testing
Unit testing best practices and test coverage

Integration testing and service contract testing

End-to-end (E2E) testing strategies

Mocking and stubbing external dependencies

Performance and load testing fundamentals

CI/CD pipeline testing integration

Test-driven development (TDD) and behavior-driven development (BDD)

Chaos testing and fault injection

6. RDBMS Architecture
ACID properties and transaction isolation levels

Database indexing strategies and query optimization

Replication types: synchronous vs asynchronous

Sharding and partitioning concepts

Connection pooling and database connection management

Write-ahead logging and crash recovery

Query execution plans and cost-based optimization

Role of the query planner and optimizer

7. Software Architectural Patterns
Monolithic architecture pros and cons

Microservices architecture and service boundaries

Service-Oriented Architecture (SOA) concepts

Serverless computing and function-as-a-service (FaaS)

Service mesh architecture and sidecar proxies

Event-driven and reactive architectures

API Gateway and Backend-for-Frontend (BFF) patterns

Circuit breaker and bulkhead patterns for resilience

8. Design Patterns and Principles
Gang of Four (GoF) design patterns overview

Creational patterns (Singleton, Factory, Builder)

Structural patterns (Adapter, Decorator, Proxy)

Behavioral patterns (Observer, Strategy, Command)

SOLID principles and their practical application

DRY, KISS, YAGNI principles in software design

Dependency Injection and Inversion of Control (IoC)

Anti-patterns and refactoring strategies

9. Web Servers
HTTP/HTTPS protocols and connection management

Reverse proxies and load balancers

Web server concurrency models (thread-per-request, event-driven)

TLS termination and SSL offloading

Caching layers in web servers (e.g., NGINX proxy cache)

Static content vs dynamic content handling

WebSocket protocol and real-time communication

Server configuration for security and performance

10. Scaling
Vertical vs horizontal scaling trade-offs

Load balancing algorithms and sticky sessions

Database scaling strategies: replication, sharding, partitioning

Caching as a scaling technique

Autoscaling policies and metrics

Designing for eventual consistency at scale

Rate limiting and backpressure mechanisms

Distributed tracing and observability in scaled systems
