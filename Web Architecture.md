# Microservices  
    ## Principles & Architecture using Spring Boot  
    1.2 API Gateway using Spring Cloud Gateway  
    1.3 Service Discovery using Eureka/Consul  
    1.4 Inter-Service Communication using REST/Messaging/Event-driven  
    1.5 Configuration Management using Spring Cloud Config Server  
    1.6 Fault Tolerance using Resilience4j/Hystrix  
    1.7 Distributed Transactions using Saga Pattern  

2. API Design  
    2.1 RESTful API Principles using Spring MVC  
    2.2 Versioning Strategies using URI/header/query parameters  
    2.3 Data Formats using JSON/XML/ProtoBuf  
    2.4 Error Handling using @ControllerAdvice  
    2.5 Documentation using Swagger/OpenAPI  
    2.6 Rate Limiting using API Gateway  

3. Security  
    3.1 Authentication using Spring Security  
    3.2 JWT using Spring Security + jjwt  
    3.3 OAuth2 using Spring Security OAuth2  
    3.4 Authorization using role-based/attribute-based access  
    3.5 OWASP Best Practices using application security best practices  
    3.6 Audit Logging using centralized logging (ELK/EFK)  

4. Monitoring & Logging  
    4.1 Actuator Monitoring using Spring Boot Actuator  
    4.2 Distributed Tracing using Sleuth/Zipkin/Jaeger  
    4.3 Log Aggregation using ELK stack  
    4.4 Alerting & Visualization using Prometheus/Grafana  

5. Scaling  
    5.1 Horizontal Scaling using Kubernetes  
    5.2 Load Balancing using Ribbon/Ingress/HAProxy  
    5.3 Auto-Scaling using Kubernetes HPA  
    5.4 Performance Optimization using caching/thread pools  
    5.5 Bottleneck Resolution using profiling/optimizing JVM  

6. Deployment  
    6.1 Containerization using Docker  
    6.2 Orchestration using Kubernetes  
    6.3 CI/CD Pipelines using Jenkins/GitHub Actions  
    6.4 Deployment Strategies using blue-green/canary/rolling  
    6.5 Environment Management using ConfigMap/Secrets  
    6.6 Zero-Downtime Deployment using readiness/liveness probes  

7. Design Patterns  
    7.1 Microservice Patterns using Aggregator/Proxy/Chained/Branch  
    7.2 Resilience Patterns using Circuit Breaker/Bulkhead/Retry  
    7.3 Data Patterns using Saga/Event Sourcing/CQRS  
    7.4 API Patterns using Gateway/Facade/Composition  

8. Additional Common Topics  
    8.1 Testing Strategies using JUnit/Testcontainers/WireMock  
    8.2 Exception Handling using @ControllerAdvice/Error payloads  
    8.3 Migration Strategies using monolith-to-microservice approaches  
    8.4 Collaboration Best Practices using branching models/code reviews  
    8.5 Documentation Standards using OpenAPI/README/style guides

9. Other Advanced Spring Boot Topics  
    10.1 Asynchronous Processing using @Async  
    10.2 Scheduled Jobs using @Scheduled  
    10.3 Batch Processing using Spring Batch  
    10.4 Retry Mechanisms using Spring Retry  
    10.5 Task Scheduling using Quartz Scheduler  
    10.6 Parallel Streams & Executor Services using Java Concurrency  
    10.7 Event-Driven Architecture using ApplicationEvents or messaging platforms (Kafka/RabbitMQ)  
    10.8 Transaction Management in async/batch contexts using Spring Transaction Manager  
    10.9 Handling Large Data Sets using chunk-oriented processing (Spring Batch)  
    10.10 Job Monitoring & Auditing using Spring Batch Admin or custom dashboards  

